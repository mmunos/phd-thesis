% !TeX spellcheck = en_US
%!TEX root = ../../Thesis.tex

Streaming query evaluation~\cite{altinel2000efficient,babcock2002models} is the task of processing queries over data streams in one pass and with a limited amount of resources. This approach is especially useful on the web, where servers share data, and they have to extract the relevant content as they receive it. For structuring the data, the de facto structure on the web is nested documents, like XML or JSON. For querying, servers use languages designed for these purposes, like XPath, XQuery, or JSON query languages.
As an illustrative example, suppose our data server (e.g., a Web API) is continuously receiving XML documents like:
\smallskip
\begin{center}
\texttt{
<doc> <a> <b/> <c/> <b/> </a> <c> <b/> <b/> </c> </doc> ...}
\end{center}
\smallskip
%\vspace{-1mm}
and for each document it has to evaluate the query $\cQ = \texttt{//a/b}$ (i.e., to extract all $b$-tags that are surrounded by an $a$-tag). The streaming query evaluation problem consists of reading these documents and finding all $b$-tags without storing the entire document on memory, that is, by making one pass over the data and spending constant time per tag. In our example, we need to retrieve the 3rd and 5th tags as soon as the last tag $\texttt{</doc>}$ is received. One could consider here that the server has to read an infinite stream and perform the query evaluation continuously, where it must enumerate partial outputs as soon as one of the XML documents ends.
%Therefore, the streaming evaluation of these queries over nested documents requires reading the data and producing all the answers as efficiently as possible.}

Researchers have studied the streaming query evaluation problem in the past, focusing on reducing the processing time or memory usage (see, e.g. \cite{BarYossefFJ07}). Hence, they spent less effort on understanding the enumeration time of such a problem, with respect to delay guarantees between outputs.
Constant-delay enumeration is a new notion of efficiency for retrieving outputs~\cite{DurandG07,Segoufin13}.
Given an instance of the problem, a constant-delay enumeration algorithm performs a preprocessing phase over the instance to build some indices and then continues with an enumeration phase. It retrieves each output, one by one, taking a delay that is constant between any two consecutive outcomes. These algorithms provide a strong guarantee of efficiency since a user knows that, after the preprocessing phase, {she} will access the output as if {the algorithm had} already computed {it}. These techniques have attracted researchers' attention, finding sophisticated solutions to several query evaluation problems~\cite{BaganDG07,BerkholzGS20,Bagan06,AmarilliBJM17,FlorenzanoRUVV20,AmarilliBMN19}. 

In this chapter, we investigate the streaming query evaluation problem over nested documents by including enumeration guarantees, like constant delay. We study the evaluation of queries given by \vpannnames (\vpanns) over nested documents.  These machines are an ``output extension'' of visibly pushdown automata, %, a model for streaming evaluation over nested documents. 
{and have the same expressive power as MSO over nested documents. 
In particular, \vpanns can define queries like $\cQ$ above or any fragment of query languages for XML or JSON included in MSO.}
Therefore, \vpanns allow considering the streaming query evaluation from a more general perspective, without getting married to a specific language (e.g., XPath). 
%Furthermore, they are general enough to understand the regular behavior of such query languages and, at the same time, they are expressive enough for defining outputs. 

We study the evaluation of \vpann over a nested document in a streaming fashion. Specifically, we want to find a streaming algorithm that reads the document sequentially and spends as little time as possible per input symbol. 
Furthermore, whenever needed, the algorithm can enumerate all outputs with output-linear delay. %, a refined notion of constant-delay for varied size results.  
The main contribution in this chapter is an algorithm with such characteristics for the class of unambiguous \vpanns. We can extend this algorithm to all \vpanns by determinization (i.e., in data complexity). 
Regarding memory usage, we bound the amount of memory used in terms of the nesting of the document and the output weight. We show that our algorithm is worst-case optimal in the sense that there are instances where the maximum amount of memory required by any streaming algorithm is at least one of these two measures.
Finally, we present some examples that show how our result can be applied to the streaming evaluation of XML and JSON query languages.
Further, we show an application of our results in the context of information extraction by document spanners~\cite{FaginKRV15}.

%We base our approach on a fully-persistent data structure~\cite{driscoll1986making} called an Enumerable Compact Set (ECS) and an algorithm that mimics the abstract machine's execution. We present this algorithm as a sequence of pseudo-code instructions that could be of special interest for practical purposes. Moreover, we believe that the presentation helps to think on further optimizations and better understand constant-delay algorithms over nested documents.  

%Our main result applies to the streaming evaluation of XML and JSON query languages. 
%In the appendix, we also show an application in the context of document spanners~\cite{FaginKRV15}.}

\paragraph{Outline of the chapter} We end this introduction by discussing some related work. 
Then in Section~\ref{nested:sec:prelim}, we describe the main terminology and models for the chapter. 
In Section~\ref{nested:sec:enum}, we discuss the notion of a streaming enumeration problem. 
In Section~\ref{nested:sec:vpann}, we define Visibly Pushdown Annotators (\vpann), the logical model we will use to represent queries over nested documents and study their expressive power. In Section~\ref{nested:sec:results}, we state the main result of the chapter and discuss some of its extent. In Section~\ref{nested:sec:ds}, we show the data structure used by the algorithm, called Enumerable Compact Set, which stores the output and handles the enumeration efficiently. Section~\ref{nested:sec:eval} presents and analyzes the main algorithm. In Section~\ref{nested:sec:spanners}, we link our results to document spanners. Finally, we discuss future work in Section~\ref{nested:sec:conclusions}. 

\paragraph{Related work} The problem of streaming query evaluation has been extensively studied in the last decades. Some work considered streaming verification, like schema validation~\cite{SegoufinV02} or type-checking~\cite{KumarMV07}, where the output is true or false. Other proposals~\cite{ChenDZ06,OlteanuFB04,JosifovskiFB05,GreenGMOS04,Olteanu07} provided streaming algorithms for XPath or XQuery's fragments; however, extending them for reaching constant-delay enumeration seems unlikely. Furthermore, most of these works~\cite{KumarMV07,GouC07,GauwinNT09} assumed outputs of fixed size (i.e., tuples). People have also considered other aspects of streaming evaluation with outputs like earliest query answering~\cite{GauwinNT09} or bounded delay~\cite{DBLP:conf/lata/GauwinNT09} (i.e., given the first visit of a node, find the earliest event that permits its selection). These aspects are orthogonal to the problem studied here.
Another line of research is~\cite{BarYossefFJ05,BarYossefFJ07}, which presents space lower bounds for evaluating fragments of XPath or XQuery over streams. These works do not consider restrictions on the delay to give outputs.  

Visibly pushdown automata~\cite{AlurM04} {are} a model usually used for streaming evaluation of boolean queries~\cite{KumarMV07}. 
In~\cite{FiliotGRS19,AlurFMRS20}, the authors studied the evaluation of transducers built from visibly pushdown automata in a streaming fashion, but none of them {saw} enumeration problems. 
Other extensions~\cite{GauwinNR08} for streaming evaluation have been analyzed but restricted to fixed-size outputs, and constant delay was not included. 

Constant-delay algorithms have been studied for several classes of query languages and structures~\cite{Segoufin13}, as we already discussed. In~\cite{Bagan06,AmarilliBJM17}, researchers considered query evaluation over trees (i.e., a different representation {for} nested documents), but their algorithms are for offline evaluation, and {it is not clear how to extend this algorithm for the online setting}. 
This research is extended with updates in~\cite{AmarilliBMN19pods}, which can encode streams by inserting new data items to the left. However, their update-time is logarithmic, whereas our proposal can do it with constant time~(i.e., in data complexity).
Furthermore, to the best of our knowledge, it is unclear how to modify the work in~\cite{AmarilliBMN19pods} to get constant update-time in our scenario.

Streaming evaluation with constant-delay enumeration was included in the context of dynamic query evaluation~{\cite{IdrisUV17,BerkholzKS17,NikolicO18,0002NOZ20}} or complex event processing~\cite{GrezRU19,GrezR20}. In both cases, the input cannot encode nested documents, and their results do not apply.

%\paragraph{New Material}
%This paper is an extended version of the article ``{\it Streaming enumeration on nested documents}'' that was published in the 25th International Conference on Database Theory (ICDT 2022). For this extended version, we have made several changes. First, we updated the query model from Visibly Pushdown Transducers to Visibly Pushdown Annotators, which simplifies the presentation and makes the model more similar to recent works about enumeration for automata~\cite{AmarilliJMR22, MunozR23}. We have improved the presentation of the enumeration algorithm, which in the previous version was relegated to the appendix and had a minor mistake. We have included further examples to support the explanation of the preprocessing algorithm. Lastly, the largest change is a new chapter in which we make a connection to document spanners and the extraction grammars of Peterfreund~\cite{liatpaper}.
%
%\cristian{Martin, escribe aqui la sección de new material. {\bf [HECHO]}}




%The main idea underlying the proof is to convert an accepting run of the VDT to a circuit which is used to represent all the outputs. This idea has already appeared earlier in several places: Bruno Courcelle, "Linear delay enumeration and monadic second-order logic",  Discret. Appl. Math. 2009 Dan Olteanu, Jakub Závodný, "Factorised Representations of Query Results: Size Bounds and Readability", ICDT 2012 Antoine Amarilli, Pierre Bourhis, Louis Jachiet, Stefan Mengel "A Circuit-Based Approach to Efficient Enumeration", ICALP 2017 Szymon Toruńczyk, "Aggregate Queries on Sparse Databases", PODS 2020

%\input{../appendix/relatedlist}

%Streaming query evaluation has been extensively studied in the last decades. 
%
%Some work consider streaming verification, like schema validation or schema typing, but here the output is boolean. \cite{Vianu}.
%
%Other proposals proposed practical streaming evaluation of subfragments of XPath or XQuery, but reaching constant-delay enumeration would be very unlikely. Most of this work consider outputs of fixed size (i.e., tuples). 
%
%In X enumeration aspects, like earliest query answering (e.g,  output nodes as early as possible, namely, once they will be selected in all possible continuations) or bounded delay (e.g., given the first visit of a node, find the earliest event that permits its selection).
%
%
%Visibly pushdown automata has been used for streaming evaluation, but usually for boolean queries. 
%In~\cite{FiliotGRS19,AlurFMRS20}, the authors studied the evaluation of VPT in a streaming fashion, but none of them looked at enumeration problems.
%Further extensions of this or similar models for streaming evaluation has been used, but restricted to fixed size outputs. Moreover, concepts like constant-delay were not included. Streaming evaluation with constant-delay enumeration was considered in the context of complex event processing or dynamic query evaluation. In both cases, query evaluation over nested documents it is not considered. 
%
%To the best of our knowledge, this is the first work on considering the evaluation of visibly pushdown transducers over nested documents with constant-delay enumeration.
%
%
%\input{../appendix/relatedlist}


% #######################################################################
%\cristian{Previous version.}
%
%A \emph{constant-delay enumeration algorithm} is an efficient solution to an enumeration problem: given an instance of the problem, the algorithm performs a update phase to build some indices, to then continue with an enumeration phase where it retrieves each output, one-by-one, taking constant-delay between consecutive outcomes.
%These algorithms provide a strong guarantee of efficiency since a user knows that, after the update phase, it will access the output as if we have already computed them. 
%For these reasons, constant-delay algorithms have attracted researchers' attention, finding sophisticated solutions on several query evaluation problems. Starting with Durand and Grandjean's work~\cite{DurandG07}, researchers have found constant-delay algorithms for various subclasses of conjunctive queries~\cite{BaganDG07,CarmeliZBKS20,BerkholzGS20}, FO queries over sparse structures~\cite{DurandG07,KazanaS11,SchweikardtSV18}, MSO queries over words and trees~\cite{Bagan06,AmarilliBJM17}, document spanners~\cite{FlorenzanoRUVV20,AmarilliBMN19}, among others~\cite{Segoufin13}.
%
%One could also develop constant-delay enumeration algorithms for query evaluation over nested documents. Indeed, some of the most relevant document schemas used online, such as XML and JSON, have a nested format. We can model the structure of these documents with the theory of \emph{nested words}, where we divide the alphabet between open and close tags and encode the data in a sequence of well-nested symbols. Many formalisms for processing nested documents can be understood with \emph{visibly pushdown automata} (VPA)~\cite{AlurM04}, an automata model with excellent algorithmic properties~\cite{alur2009adding}. Moreover, there have been studies of its natural extension to transducers~\cite{FiliotRRST18}, called \emph{visibly pushdown transducers} (VPT), a model for processing nested documents and producing outputs. The main advantage of these models compared to other models of nesting structures (e.g., automata over trees) is that it allows processing naturally the input in a streaming fashion, reducing the number of resources needed to fulfill its task. 
%
%This paper presents a constant-delay enumeration algorithm for evaluating VPT over nested words. Specifically, we study the combined complexity of evaluating a VPT $\cT$ over an input word $w$ and consider the notion of output-linear delay~\cite{FlorenzanoRUVV20}, a refinement of the idea of constant-delay where the delay between outputs depends only the size of two consecutive outcomes, namely, constant with respect to $\cT$ and $w$. Therefore, we provide an output-linear delay enumeration algorithm that takes preprocessing time $|\cT|^3 \cdot |w|$, namely, linear in the size of the input word, for a reasonably expressive class of VPT. 
%
%	
%Towards the end of this work, we apply our results to study efficient enumeration algorithms in information extraction. More specifically, we use our techniques to derive an output-linear delay algorithm for evaluating visibly pushdown extraction grammars, a subclass of extraction grammars~\cite{liatpaper}. This solution is the first practical algorithm (i.e., linear preprocessing) to evaluate a subclass of recursive document spanners efficiently~\cite{PeterfreundCFK19}.
%
%\smallskip
%
%\noindent \textbf{Related work.} Constant-delay algorithms have been studied for several classes of query languages and structures~\cite{Segoufin13}, as we already discussed. The approach of~\cite{Bagan06,AmarilliBJM17} is the closest to this work (see the discussion above). Algorithms for processing nested documents (e.g., XML) with one-pass~\cite{GauwinNT09} or constant-delay~\cite{BojanczykP11} have been studied previously; however, they are interested in different problems not directly related to this work. In~\cite{FiliotGRS19,AlurFMRS20}, the authors studied the evaluation of VPT in a streaming fashion, but none of them looked at enumeration problems. Very recently, extensions of document spanners with recursion have been considered~\cite{PeterfreundCFK19, liatpaper}. In these works, the question of investigating nested documents is not addressed. To the best of our knowledge, this is the first work on considering the evaluation of visibly pushdown transducers over nested documents with constant-delay enumeration.
%
%\input{../appendix/relatedlist}
