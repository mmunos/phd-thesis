Before reading this proof, it is important to note that the argument assumes the understanding of Algorithm~\ref{nested:alg:preprocessing}. Furthermore, this proof uses the notation introduce in Section~\ref{nested:sec:eval}.

First of all, note that the time bounds are implied by Theorem~\ref{nested:theo:main}, so we will restrict to prove the space bounds. 
Algorithm~\ref{nested:alg:preprocessing} has an update phase and an enumeration phase, and the enumeration phase only processes the data structure that was built on the update phase, using at most linear extra space, as is explained in Section~\ref{nested:sec:ds}. As such, we will prove that Algorithm~\ref{nested:alg:preprocessing} on input $(\cT, w)$ uses $\cO((\depth(w) + \outgap(\cT,w))\times|Q|^2|\Delta|)$ space at every point in its execution, which implies the statement of the proposition, where $w = \Stream[1,n]$ for some stream $\Stream$ and $n$.

As it was explained in Section~\ref{nested:sec:eval}, Algorithm~\ref{nested:alg:preprocessing} uses a hash table $S$, and a stack $T$ that stores hash tables. The size of the stack at each point is bounded $\depth(w)$, and the size of each hash table is bounded by $|Q|^2|\Gamma|$, so the size of $S$ and $T$ combined is in $\cO(\depth(w)|Q|^2|\Delta|)$. The rest of the space used is related to the \dsepsabbr $\cD$, which we will now bound by $\cO(\outgap(\cT,w[1,k])|Q|^2|\Delta|)$ at each~step~$k$.

For every step $k$ of the algorithm, consider an \dsepsabbr $\cD^{\textsf{trim}}_k$ which is composed solely of the nodes that are reachable from of the ones stored in $S^k$, or the ones stored in some hash table in $T^k$. A simple induction argument on $k$ shows that the rest of the nodes in $\cD$ can be discarded with no effect over the correctness of the algorithm, so they are not considered in the memory used by it. Therefore, proving that at each step $| \cD^{\textsf{trim}}_k | \in \cO(\outgap(\cT,w[1,k])|Q|^2|\Delta|)$ is enough to complete the proof. 

Let $\cI$ be the set of positions less than $k$ that appear in some output of $\sem{\cT}(w[1,k] \cdot w')$ for some $w \cdot w'\in \pwnS$. We now refer to Lemma~\ref{nested:vpt:steps} since it implies that for each node $v$ stored in $S^k$ or the topmost hash table in $T^k$, each sequence in $\L_{\D}(v)$ corresponds to at least one valid run of $\cT$ over $w[1,k]$, and since $\cT$ is trimmed, each one of these runs is part of an accepting run of $\cT$ over $w[1,k] \cdot w'$, for some word $w'$. Therefore, each of the positions that appear in some of these sets is in $\cI$. Furthermore, we can use this lemma to characterize the positions in the rest of the hash tables in $T^k$, since appending any close symbol $\cl{a}$ to $w[1,k]$ will make the algorithm pop an element from $T$, which will make the next hash table the topmost. This argument can be extended to any of the hash tables in $T^k$, so in all, Lemma~\ref{nested:vpt:steps} implies that all of the positions that appear in some non-empty leaf in $\cD^{\textsf{trim}}_k $ are in $\cI$. Theorem~\ref{nested:theo:main} implies that the set of these positions corresponds exactly to $\cI$, since if there was any position in $\cI$ missing from the leaves in $\cD$, the algorithm would not be correct.

Lastly, we will show that $| \cD^{\textsf{trim}}_k | \leq | \cI | \times |Q|^2|\Delta| \times d$, where $d$ is a constant. Towards this goal, we will bound the number of $\eps$-leaves, non-empty leaves, and product nodes by $\cO(| \cI | \times |Q|^2|\Delta|)$ independently. Union nodes can be bounded by counting the other types of nodes: The only cases where a union node is created are (1) in line \ref{nested:line35}, only after a product node had been created, (2) during the creation of a product node (as described in Theorem~\ref{nested:theo:data-structure-eps}), (3) in line \ref{nested:line46}, but only whenever one of the previous lines had created either a product node or a non-empty leaf node, and (4) in line \ref{nested:line15}, which only happens once at the end of the update phase, and iterates by nodes in $S$. Thus, the number of union nodes created at this for loop at most $| \cD^{\textsf{trim}}_k |$. The number of $\eps$-nodes is at most one, owing to Theorem~\ref{nested:theo:data-structure-eps}, since its proof shows that at the end of step $k$, each of the nodes in $\cD^{\textsf{trim}}_k$ is $\eps$-safe. The number of non-empty leaves can be straightforwardly shown to be $\cO(| \cI | \times |Q|^2|\Delta|)$ since each of these leaves was introduced in some step in $\cI$, and in each one of these steps, the number of operations that the algorithm does is in $\cO(|Q|^2|\Delta|)$. 

To show a bound over the number of product nodes, consider a slight modification of Algorithm~\ref{nested:alg:preprocessing}: 
product nodes that are created in line \ref{nested:line44} are labeled with the step $k$ in which the algorithm is at the moment. 
Now, for a set of nodes $A$ let $\cD^{\textsf{trim}}_A$ be the \dsepsabbr that is obtained by removing all of the nodes that are not reachable from some node in $A$ from $\cD$.
Let $\cI_A$ be the set of positions that appear in some non-empty leaf node in $\cD^{\textsf{trim}}_A$, and let ${\mathcal P}_A$ be the set of step labels that appear in some product node in $\cD^{\textsf{trim}}_A$ excluding the steps in $\cI_A$. Also, let $V_k$ be the the set of nodes in $\cD^{\textsf{trim}}_k$. We will show by induction on $k$ that $| {\mathcal P}_A | \leq | \cI_A | - 1$ for any $A\subseteq V_k$ which contains at least one node that is not an $\eps$-node. Consider any set $A \subseteq V_k$. The first observation we make here is that we can partition the nodes in $A$ to a collection $\{A_H\}$ of sets of nodes depending on the hash table $H$ they are reachable from, given that they are in $\cD^{\textsf{trim}}_k$. Let ${\mathcal Q}_A = {\mathcal P}_A \cup \cI_A$. From Lemma~\ref{nested:vpt:steps} we get that for two different sets $A_{H_1}$ and $A_{H_2}$ in the collection, the sets ${\mathcal Q}_{H_1}$ and ${\mathcal Q}_{H_2}$ are disjoint. 
Therefore, in step $k$, if the algorithm enters $\textsc{CloseStep}$, we only need to focus on the set $A_{S}$, and if the algorithm enters $\textsc{OpenStep}$ on the set and $A_{T^k}$ (note that in this case, $S^k$ is composed only of $\eps$-nodes). The rest of the hash tables were reachable  on a previous step, so the inequality can be reached by adding up the inequalities that held in those steps. 
First, note that if none of the product nodes in $A$ were created in step $k$, then we can consider the set $B$ of nodes reachable from $A$ that were created in a previous step and notice that ${\mathcal P}_A = {\mathcal P}_B$ and $\cI_B \subseteq \cI_A$, so the statement follows since $B \subseteq V_{k-1}$. 
Also, note that if the algorithm in step $k$ enters $\textsc{OpenStep}$, all of the product nodes created in this step are directly connected to a non-$\eps$ leaf created in this same step, so the statement also follows. 
From this point on, we can assume that the algorithm enters $\textsc{CloseStep}$ on step $k$, and all of the nodes in $A$ are reachable from some node in $S^k$, and there is at least one product node in $A$ that was created in step $k$. Let $P$ be the set of product nodes in $A$ that were created on step $k$. Consider the span $\clevel(k) = \spanc{j}{k}$. 
The \textsf{prod} operation in line \ref{nested:line44} either creates a new product node, or makes $v$ reference a node that already existed in $S^{k-1}$ or the topmost table in $T^j$. 
Furthermore, if a product node is created in line \ref{nested:line44}, then Theorem~\ref{nested:theo:data-structure-eps} tells us that it must be connected to a node in $S^{k-1}$ that is not an $\eps$-node, and to a node in the topmost table in $T^j$ that is also not an $\eps$-node. Consider now the set of nodes $B$ that is made up of (1) nodes in $A$ that are reachable from $S^{k-1}$ and (2) nodes in $S^{k-1}$ that are connected to a product node in $P$. Consider also the set of nodes $C$ that is made up of (1) nodes in $A$ that are reachable from the topmost table in $T^j$, and nodes in the topmost table in $T^j$ that are connected to a node in $P$. Note that both sets $B$ and $C$ contain a non-$\eps$ node, and are composed of nodes created in a previous step, so assume that $|{\mathcal P}_B| \leq |\cI_B| -1$ and that $|{\mathcal P}_C| \leq |\cI_C| -1$. It can be seen that every node in $\cD^{\textsf{trim}}_A$ is either in $B$, $C$, or was created on step $k$, so we get that ${\mathcal P}_A = {\mathcal P}_B \cup {\mathcal P}_C \cup \{k\}$ and $\cI_A \supseteq \cI_B \cup \cI_C$. From Lemma~\ref{nested:vpt:steps} we get that ${\mathcal Q}_B$ and ${\mathcal Q}_C$ are disjoint, and putting these facts to together gives us that $| {\mathcal P}_A | =  |{\mathcal P}_B| + |{\mathcal P}_C| + 1\leq |\cI_B| + |\cI_C| - 1 \leq |\cI_A|-1$.

Having proven this statement, we can deduce that the number of product nodes in $\cD^{\textsf{trim}}_k$ is in $\cO(| \cI | \times |Q|^2|\Delta|)$ since the number of steps where they are created is bounded by $|\cI|$. Therefore, $| \cD^{\textsf{trim}}_k | \leq | \cI | \times |Q|^2|\Delta| \times d$, for some constant $d$. This concludes the proof. \hfill \qed